#include <esp_now.h>
#include <WiFi.h>
#include <MD_MAX72xx.h>
#include <SPI.h>

// ======== CONFIG ========
#define DEVICE_ID 1  // Change this for each device
const char* ROLE = "BEACON_SCANNER";

// ======== LED MATRIX CONFIG ========
#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_DEVICES 1
#define DATA_PIN 23   // Update these pins based on your wiring
#define CLK_PIN 18
#define CS_PIN 5

MD_MAX72XX matrix = MD_MAX72XX(HARDWARE_TYPE, DATA_PIN, CLK_PIN, CS_PIN);

// ======== Known Devices ========
uint8_t known_macs[][6] = {
  {0x5C, 0x01, 0x3B, 0x74, 0x46, 0x34}, // Device 1
  {0x5C, 0x01, 0x3B, 0x74, 0x74, 0x1C}, // Device 2
  {0x24, 0x6F, 0x28, 0x1A, 0x2B, 0x3C}, // Device 3
  {0x30, 0xAE, 0xA4, 0x4B, 0xC0, 0xD1}, // Device 4
  {0x7C, 0x9E, 0xBD, 0x2F, 0xA4, 0x55}  // Device 5
};
const int known_mac_count = sizeof(known_macs) / sizeof(known_macs[0]);

// Target MAC: Device 2
const uint8_t target_mac[6] = {0x5C, 0x01, 0x3B, 0x74, 0x74, 0x1C};

// ======== Message Structure ========
typedef struct struct_message {
  char device_type[20];
  int device_id;
  unsigned long timestamp;
  int tx_power;
} struct_message;

struct_message outgoing_msg;
struct_message incoming_msg;

// ======== MAC Utilities ========
bool isKnownMAC(const uint8_t* mac) {
  for (int i = 0; i < known_mac_count; i++) {
    bool match = true;
    for (int j = 0; j < 6; j++) {
      if (mac[j] != known_macs[i][j]) {
        match = false;
        break;
      }
    }
    if (match) return true;
  }
  return false;
}

void printMAC(const uint8_t* mac) {
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", mac[i]);
    if (i < 5) Serial.print(":");
  }
}

// ======== LED Display Helpers ========
int mapRSSIToRows(int rssi) {
  if (rssi >= -45) return 8;      // Very close
  else if (rssi >= -50) return 7; // Close
  else if (rssi >= -55) return 6; // Close
  else if (rssi >= -60) return 5; // Close
  else if (rssi >= -65) return 4; // Medium
  else if (rssi >= -70) return 3; // Medium
  else if (rssi >= -75) return 2; // Far
  else if (rssi >= -80) return 1; // Far
  else return 0;                  // Too far or not visible
}

void displayRows(int rowsToLight) {
  matrix.clear();
  for (int row = 0; row < rowsToLight; row++) {
    for (int col = 0; col < 8; col++) {
      matrix.setPoint(row, col, true);  // (row, col, state)
    }
  }
  matrix.update();
}

// ======== ESP-NOW Callbacks ========
void OnDataRecv(const esp_now_recv_info *info, const uint8_t *data, int len) {
  if (!isKnownMAC(info->src_addr)) {
    Serial.print("‚ùå Unknown MAC: ");
    printMAC(info->src_addr);
    Serial.println(" ‚Äî Ignored");
    return;
  }

  int rssi = info->rx_ctrl->rssi;
  memcpy(&incoming_msg, data, sizeof(incoming_msg));

  Serial.println(">>> MESSAGE RECEIVED <<<");
  Serial.print("From MAC: ");
  printMAC(info->src_addr);
  Serial.println();
  Serial.printf("Device ID: %d\n", incoming_msg.device_id);
  Serial.printf("Timestamp: %lu ms\n", incoming_msg.timestamp);
  Serial.printf("RSSI: %d dBm\n", rssi);
  Serial.println("---------------------------------------------");

  // Only visualize signal from Device 2
  if (memcmp(info->src_addr, target_mac, 6) == 0) {
    int rows = mapRSSIToRows(rssi);
    Serial.printf("üí° Lighting %d rows for RSSI %d\n", rows, rssi);
    displayRows(rows);
  }
}

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("üì§ Sent to ");
  printMAC(mac_addr);
  Serial.print(" ‚Äî Status: ");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "‚úÖ Success" : "‚ùå Failed");
}

// ======== Setup ========
void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println("ESP-NOW MULTI-DEVICE SYSTEM STARTING...");

  // Matrix setup
  matrix.begin();
  matrix.clear();
  matrix.control(MD_MAX72XX::INTENSITY, 5);
  matrix.update();

  // WiFi + ESP-NOW init
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  WiFi.setTxPower(WIFI_POWER_19_5dBm);

  Serial.print("This device MAC: ");
  Serial.println(WiFi.macAddress());

  if (esp_now_init() != ESP_OK) {
    Serial.println("‚ùå ESP-NOW initialization failed");
    return;
  }

  esp_now_register_recv_cb(OnDataRecv);
  esp_now_register_send_cb(OnDataSent);

  // Add peers
  for (int i = 0; i < known_mac_count; i++) {
    if (memcmp(known_macs[i], WiFi.macAddress().c_str(), 6) == 0) continue;

    esp_now_peer_info_t peerInfo = {};
    memcpy(peerInfo.peer_addr, known_macs[i], 6);
    peerInfo.channel = 0;
    peerInfo.encrypt = false;

    if (esp_now_add_peer(&peerInfo) == ESP_OK) {
      Serial.print("‚úÖ Added peer: ");
      printMAC(known_macs[i]);
      Serial.println();
    } else {
      Serial.print("‚ùå Failed to add peer: ");
      printMAC(known_macs[i]);
      Serial.println();
    }
  }

  strcpy(outgoing_msg.device_type, ROLE);
  outgoing_msg.device_id = DEVICE_ID;
  outgoing_msg.tx_power = 19;
}

// ======== Loop ========
unsigned long last_send = 0;
const unsigned long send_interval = 1000;

void loop() {
  if (millis() - last_send >= send_interval) {
    last_send = millis();
    outgoing_msg.timestamp = millis();

    for (int i = 0; i < known_mac_count; i++) {
      if (memcmp(known_macs[i], WiFi.macAddress().c_str(), 6) == 0) continue;

      esp_err_t result = esp_now_send(known_macs[i], (uint8_t*)&outgoing_msg, sizeof(outgoing_msg));
      Serial.print("‚è± Sending to ");
      printMAC(known_macs[i]);
      Serial.print(" ‚Äî Result: ");
      Serial.println(result == ESP_OK ? "‚úÖ Success" : "‚ùå Failed");
    }
  }

  delay(100);
}
